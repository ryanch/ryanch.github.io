<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Foreshadow Puzzle</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: white;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #character {
            position: absolute;
            width: 64px;
            height: 64px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        #debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
        }

        .text-container {
            position: absolute;
            font-size: 48px;
            font-weight: bold;
            color: #333;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            pointer-events: none;
        }

        .text-container.visible {
            opacity: 1;
        }

        #text-top {
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            justify-content: center;
            max-width: 90%;
        }

        #text-bottom {
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            justify-content: center;
            max-width: 90%;
        }

        #text-left {
            left: 50px;
            top: 50%;
            transform: translateY(-50%);
            align-items: flex-start;
            width: 40%;
        }

        #text-right {
            right: 50px;
            top: 50%;
            transform: translateY(-50%);
            align-items: flex-end;
            width: 40%;
            justify-content: flex-end;
        }

        .word {
            position: relative;
            cursor: default;
            transition: color 0.2s ease;
        }

        .word.hover {
            color: #0066cc;
            text-shadow: 2px 2px 4px rgba(0, 102, 204, 0.3);
        }

        .word.strikethrough {
            text-decoration: line-through;
            text-decoration-thickness: 3px;
        }

        #carried-word {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            color: #0066cc;
            pointer-events: none;
            display: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        #carried-word.visible {
            display: block;
        }

        #reload-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background-color: rgba(0, 102, 204, 0.8);
            color: white;
            border: 2px solid rgba(0, 102, 204, 1);
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease, background-color 0.2s ease;
        }

        #reload-button.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #reload-button:hover {
            background-color: rgba(0, 102, 204, 1);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="text-top" class="text-container"></div>
        <div id="text-left" class="text-container"></div>
        <div id="text-right" class="text-container"></div>
        <div id="text-bottom" class="text-container"></div>
        <div id="carried-word"></div>
        <img id="character" src="frames/08_Elliot_RPG_Walk Down_0.png" alt="Character">
        <div id="debug-info"></div>
        <button id="reload-button">Reload</button>
    </div>

    <script src="scenes.js"></script>
    <script>
        const character = document.getElementById('character');
        const gameContainer = document.getElementById('game-container');
        const debugInfo = document.getElementById('debug-info');
        const textContainers = {
            top: document.getElementById('text-top'),
            left: document.getElementById('text-left'),
            right: document.getElementById('text-right'),
            bottom: document.getElementById('text-bottom')
        };
        const carriedWordElement = document.getElementById('carried-word');
        const reloadButton = document.getElementById('reload-button');

        // Game state
        const game = {
            x: window.innerWidth / 2 - 32,
            y: window.innerHeight / 2 - 32,
            speed: 3.5,
            direction: 'down',
            frame: 0,
            isMoving: false,
            hasStartedMoving: false,
            carriedWord: null,
            keys: {
                w: false,
                a: false,
                s: false,
                d: false
            }
        };

        // Text blocks management
        const textBlocks = {
            top: [],
            left: [],
            right: [],
            bottom: []
        };
        let currentHoveredWord = null;
        let lastHoveredWords = new Set(); // Track which words we were hovering last frame

        // Scene management
        let currentScene = null;
        let triggeredBlocks = new Set();

        // Normalize text for matching (lowercase, remove punctuation, remove strikethrough, collapse spaces)
        function normalizeText(location) {
            const words = textBlocks[location];
            const textParts = words
                .filter(word => !word.strikethrough)
                .map(word => word.text);
            const text = textParts.join(' ');
            // Remove punctuation and convert to lowercase
            const normalized = text.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '').toLowerCase();
            // Collapse multiple spaces
            return normalized.replace(/\s+/g, ' ').trim();
        }

        // Check if text matches a pattern (supports * wildcard)
        function matchesPattern(text, pattern) {
            // Normalize the pattern the same way text is normalized
            // Remove punctuation and convert to lowercase, but preserve *
            const normalizedPattern = pattern
                .replace(/[.,\/#!$%\^&\;:{}=\-_`~()]/g, '')
                .toLowerCase()
                .replace(/\s+/g, ' ')
                .trim();

            // Escape special regex characters except *
            const regexPattern = normalizedPattern
                .replace(/[.+?^${}()|[\]\\]/g, '\\$&')
                .replace(/\*/g, '.*');
            const regex = new RegExp('^' + regexPattern + '$', 'i');
            return regex.test(text);
        }

        // Get scene by name
        function getScene(sceneName) {
            return scenes.find(s => s.scene === sceneName);
        }

        // Parse action key (e.g., "setTopText1" -> {action: "setText", location: "top", order: 1})
        function parseActionKey(key) {
            const setTextMatch = key.match(/^set(Top|Left|Right|Bottom)Text(\d+)$/);
            if (setTextMatch) {
                return {
                    action: 'setText',
                    location: setTextMatch[1].toLowerCase(),
                    order: parseInt(setTextMatch[2])
                };
            }
            if (key === 'gotoScene') {
                return { action: 'gotoScene' };
            }
            return null;
        }

        // Execute actions with proper ordering and timing
        function executeActions(actions) {
            // Group actions by order
            const actionsByOrder = {};
            const gotoSceneAction = { action: null, value: null };

            Object.entries(actions).forEach(([key, value]) => {
                const parsed = parseActionKey(key);
                if (!parsed) return;

                if (parsed.action === 'gotoScene') {
                    gotoSceneAction.action = parsed.action;
                    gotoSceneAction.value = value;
                } else if (parsed.action === 'setText') {
                    const order = parsed.order || 1;
                    if (!actionsByOrder[order]) {
                        actionsByOrder[order] = [];
                    }
                    actionsByOrder[order].push({ ...parsed, value });
                }
            });

            // Execute setText actions in order with delays
            const orders = Object.keys(actionsByOrder).sort((a, b) => a - b);
            orders.forEach((order, index) => {
                const delay = index * 2000; // 2 seconds between each order
                setTimeout(() => {
                    actionsByOrder[order].forEach(action => {
                        setText(action.location, action.value, true);
                    });
                }, delay);
            });

            // Execute gotoScene if present (after all setText actions)
            if (gotoSceneAction.action === 'gotoScene') {
                const totalDelay = orders.length * 2000 + 500;
                setTimeout(() => {
                    loadScene(gotoSceneAction.value);
                }, totalDelay);
            }
        }

        // Check if_ triggers
        function checkTriggers() {
            if (!currentScene) return;

            const scene = getScene(currentScene);
            if (!scene) return;

            // Check all if_ blocks
            Object.entries(scene).forEach(([key, block]) => {
                if (!key.startsWith('if_')) return;
                if (triggeredBlocks.has(key)) return; // Already triggered

                const pattern = block.match;
                if (!pattern) return;

                // Check each location separately
                ['top', 'left', 'right', 'bottom'].forEach(location => {
                    const normalized = normalizeText(location);
                    if (matchesPattern(normalized, pattern)) {
                        // Trigger this block
                        triggeredBlocks.add(key);
                        executeActions(block);
                    }
                });
            });
        }

        // Load a scene
        function loadScene(sceneName) {
            const scene = getScene(sceneName);
            if (!scene) {
                console.error('Scene not found:', sceneName);
                return;
            }

            const isFirstLoad = currentScene === null;
            currentScene = sceneName;
            triggeredBlocks.clear();

            // Clear carried word
            game.carriedWord = null;

            // Show reload button after first scene loads
            if (isFirstLoad) {
                reloadButton.classList.add('visible');
            }

            // Fade out all existing text (skip if first load)
            if (!isFirstLoad) {
                ['top', 'left', 'right', 'bottom'].forEach(location => {
                    textContainers[location].classList.remove('visible');
                });
            }

            // Wait for fade-out transition to complete (1.5s) before clearing and loading new scene
            // Skip delay on first load since there's nothing to fade out
            const fadeOutDelay = isFirstLoad ? 0 : 1500;
            setTimeout(() => {
                // Clear all text content
                ['top', 'left', 'right', 'bottom'].forEach(location => {
                    setText(location, '', false);
                });

                // Execute start actions after a small delay to ensure clean slate
                setTimeout(() => {
                    if (scene.start) {
                        executeActions(scene.start);
                    }
                }, 50);
            }, fadeOutDelay);
        }

        // Validate scenes.js file format
        function validateScenes() {
            const errors = [];
            const warnings = [];

            if (!Array.isArray(scenes)) {
                errors.push('scenes must be an array');
                return { valid: false, errors, warnings };
            }

            const sceneNames = new Set();

            scenes.forEach((scene, index) => {
                const sceneId = `Scene ${index}`;

                // Check for required 'scene' field
                if (!scene.scene) {
                    errors.push(`${sceneId}: Missing required 'scene' field`);
                } else {
                    if (typeof scene.scene !== 'string') {
                        errors.push(`${sceneId}: 'scene' must be a string`);
                    }
                    if (sceneNames.has(scene.scene)) {
                        errors.push(`${sceneId}: Duplicate scene name '${scene.scene}'`);
                    }
                    sceneNames.add(scene.scene);
                }

                // Check start block if present
                if (scene.start) {
                    if (typeof scene.start !== 'object') {
                        errors.push(`${sceneId} (${scene.scene}): 'start' must be an object`);
                    } else {
                        validateActions(scene.start, `${sceneId} (${scene.scene}) start`, errors, warnings);
                    }
                }

                // Check if_ blocks
                Object.entries(scene).forEach(([key, block]) => {
                    if (!key.startsWith('if_')) return;
                    if (key === 'if_') {
                        errors.push(`${sceneId} (${scene.scene}): if_ block must have a name after 'if_'`);
                        return;
                    }

                    if (typeof block !== 'object') {
                        errors.push(`${sceneId} (${scene.scene}) ${key}: if_ block must be an object`);
                        return;
                    }

                    if (!block.match) {
                        errors.push(`${sceneId} (${scene.scene}) ${key}: Missing required 'match' field`);
                    } else if (typeof block.match !== 'string') {
                        errors.push(`${sceneId} (${scene.scene}) ${key}: 'match' must be a string`);
                    }

                    validateActions(block, `${sceneId} (${scene.scene}) ${key}`, errors, warnings);
                });
            });

            return {
                valid: errors.length === 0,
                errors,
                warnings
            };
        }

        // Validate action block
        function validateActions(actions, location, errors, warnings) {
            const validLocations = ['Top', 'Left', 'Right', 'Bottom'];
            const referencedScenes = new Set();

            Object.entries(actions).forEach(([key, value]) => {
                if (key === 'match') return; // Skip match field

                const setTextMatch = key.match(/^set(Top|Left|Right|Bottom)Text(\d+)$/);
                if (setTextMatch) {
                    const loc = setTextMatch[1];
                    const order = parseInt(setTextMatch[2]);

                    if (!validLocations.includes(loc)) {
                        errors.push(`${location}: Invalid location '${loc}' in '${key}'`);
                    }
                    if (order < 1 || order > 4) {
                        warnings.push(`${location}: Order ${order} in '${key}' is outside typical range (1-4)`);
                    }
                    if (typeof value !== 'string') {
                        errors.push(`${location}: Value for '${key}' must be a string`);
                    }
                } else if (key === 'gotoScene') {
                    if (typeof value !== 'string') {
                        errors.push(`${location}: gotoScene value must be a string`);
                    } else {
                        referencedScenes.add(value);
                    }
                } else {
                    warnings.push(`${location}: Unknown action '${key}'`);
                }
            });

            // Check if referenced scenes exist
            referencedScenes.forEach(sceneName => {
                if (!scenes.find(s => s.scene === sceneName)) {
                    errors.push(`${location}: Referenced scene '${sceneName}' does not exist`);
                }
            });
        }

        // Test suite for match feature
        function runMatchTests() {
            console.log('=== Running Match Feature Tests ===');

            const tests = [
                // User's specific test case
                {
                    name: "User test: 'The hero opened chest.' matches '*hero opened chest.'",
                    text: "The hero opened chest.",
                    pattern: "*hero opened chest.",
                    expected: true
                },
                // Basic exact match
                {
                    name: "Exact match",
                    text: "hello world",
                    pattern: "hello world",
                    expected: true
                },
                // Exact match with different case
                {
                    name: "Case insensitive match",
                    text: "Hello World",
                    pattern: "hello world",
                    expected: true
                },
                // Wildcard at start
                {
                    name: "Wildcard at start",
                    text: "the big door",
                    pattern: "*door",
                    expected: true
                },
                // Wildcard at end
                {
                    name: "Wildcard at end",
                    text: "the big door",
                    pattern: "the*",
                    expected: true
                },
                // Wildcard in middle
                {
                    name: "Wildcard in middle",
                    text: "the big heavy door",
                    pattern: "the*door",
                    expected: true
                },
                // Multiple wildcards
                {
                    name: "Multiple wildcards",
                    text: "the big locked heavy wooden door",
                    pattern: "the*locked*door",
                    expected: true
                },
                // Punctuation removed in normalization
                {
                    name: "Punctuation removed",
                    text: "hello, world!",
                    pattern: "hello world",
                    expected: true
                },
                // Should not match - different text
                {
                    name: "No match - different text",
                    text: "hello world",
                    pattern: "goodbye world",
                    expected: false
                },
                // Should not match - pattern requires more
                {
                    name: "No match - pattern too specific",
                    text: "door",
                    pattern: "the door",
                    expected: false
                },
                // Wildcard matches empty string
                {
                    name: "Wildcard matches nothing",
                    text: "the door",
                    pattern: "the*door",
                    expected: true
                },
                // Complex example with punctuation
                {
                    name: "Complex with punctuation",
                    text: "The hero walked around, searching for the door.",
                    pattern: "*hero*door",
                    expected: true
                },
                // Test with period
                {
                    name: "Pattern with period at end",
                    text: "opened chest.",
                    pattern: "opened chest",
                    expected: true
                },
                // Another user scenario variant
                {
                    name: "Variant: 'hero opened chest' matches '*opened chest'",
                    text: "hero opened chest",
                    pattern: "*opened chest",
                    expected: true
                }
            ];

            let passed = 0;
            let failed = 0;

            tests.forEach((test, index) => {
                // Normalize text (simulate what normalizeText does)
                const normalizedText = test.text
                    .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '')
                    .toLowerCase()
                    .replace(/\s+/g, ' ')
                    .trim();

                const result = matchesPattern(normalizedText, test.pattern);
                const status = result === test.expected ? 'PASS' : 'FAIL';

                if (result === test.expected) {
                    passed++;
                    console.log(`✓ Test ${index + 1}: ${test.name}`);
                } else {
                    failed++;
                    console.error(`✗ Test ${index + 1}: ${test.name}`);
                    console.error(`  Text: "${test.text}" (normalized: "${normalizedText}")`);
                    console.error(`  Pattern: "${test.pattern}"`);
                    console.error(`  Expected: ${test.expected}, Got: ${result}`);
                }
            });

            console.log('\n=== Test Summary ===');
            console.log(`Total: ${tests.length}`);
            console.log(`Passed: ${passed}`);
            console.log(`Failed: ${failed}`);
            console.log(`Success Rate: ${((passed / tests.length) * 100).toFixed(1)}%`);
            console.log('====================\n');

            return { passed, failed, total: tests.length };
        }

        // Run match tests at startup
        runMatchTests();

        // Run validation on load
        const validation = validateScenes();
        if (!validation.valid) {
            console.error('Scene validation errors:');
            validation.errors.forEach(err => console.error('  - ' + err));
        }
        if (validation.warnings.length > 0) {
            console.warn('Scene validation warnings:');
            validation.warnings.forEach(warn => console.warn('  - ' + warn));
        }
        if (validation.valid) {
            console.log('Scenes file validated successfully');
        }

        // Set text for a specific location
        function setText(location, text, fadeIn = true) {
            const container = textContainers[location];
            if (!container) return;

            // Clear existing text
            container.innerHTML = '';
            textBlocks[location] = [];

            if (!text) return;

            // Ensure container is hidden before adding new content
            container.classList.remove('visible');

            // Create word elements
            const wordArray = text.split(' ');
            wordArray.forEach((wordText, index) => {
                const wordSpan = document.createElement('span');
                wordSpan.className = 'word';
                wordSpan.textContent = wordText;
                wordSpan.dataset.location = location;
                wordSpan.dataset.index = index;
                container.appendChild(wordSpan);

                textBlocks[location].push({
                    element: wordSpan,
                    text: wordText,
                    strikethrough: false,
                    location: location,
                    index: index
                });
            });

            // Fade in if requested (after a brief delay to ensure initial state is rendered)
            if (fadeIn) {
                // Force a reflow to ensure the opacity:0 state is rendered before transitioning
                container.offsetHeight;
                requestAnimationFrame(() => {
                    container.classList.add('visible');
                });
            }
        }

        // Get all words from all text blocks
        function getAllWords() {
            const allWords = [];
            ['top', 'left', 'right', 'bottom'].forEach(location => {
                allWords.push(...textBlocks[location]);
            });
            return allWords;
        }

        // Check collision between character and word
        function checkWordCollision(wordElement) {
            const charRect = character.getBoundingClientRect();
            const wordRect = wordElement.getBoundingClientRect();

            return !(charRect.right < wordRect.left ||
                     charRect.left > wordRect.right ||
                     charRect.bottom < wordRect.top ||
                     charRect.top > wordRect.bottom);
        }

        // Update word hover states
        function updateWordHovers() {
            const allWords = getAllWords();
            const currentlyCollidingWords = new Set();

            // Find all words we're currently colliding with
            allWords.forEach(word => {
                if (checkWordCollision(word.element)) {
                    const wordId = `${word.location}_${word.index}`;
                    currentlyCollidingWords.add(wordId);
                }
            });

            // Check if we've touched a new word (not in lastHoveredWords)
            let newlyTouchedWord = null;
            for (const wordId of currentlyCollidingWords) {
                if (!lastHoveredWords.has(wordId)) {
                    // This is a newly touched word
                    const [location, index] = wordId.split('_');
                    newlyTouchedWord = textBlocks[location][parseInt(index)];
                    break; // Use the first newly touched word we find
                }
            }

            // Update the current hovered word
            if (newlyTouchedWord) {
                // We touched a new word, select it
                currentHoveredWord = newlyTouchedWord;
            } else if (currentHoveredWord) {
                // Check if we're still hovering the current word
                const currentWordId = `${currentHoveredWord.location}_${currentHoveredWord.index}`;
                if (!currentlyCollidingWords.has(currentWordId)) {
                    // We're no longer touching the current word
                    // If we're still colliding with other words, select one of them
                    if (currentlyCollidingWords.size > 0) {
                        // Select the first word we're colliding with
                        const wordId = Array.from(currentlyCollidingWords)[0];
                        const [location, index] = wordId.split('_');
                        currentHoveredWord = textBlocks[location][parseInt(index)];
                    } else {
                        currentHoveredWord = null;
                    }
                }
            }

            // Update hover class - only the current hovered word should have it
            allWords.forEach(word => {
                if (word === currentHoveredWord) {
                    word.element.classList.add('hover');
                } else {
                    word.element.classList.remove('hover');
                }
            });

            // Update lastHoveredWords for next frame
            lastHoveredWords = currentlyCollidingWords;
        }

        // Update carried word position
        function updateCarriedWord() {
            if (game.carriedWord) {
                carriedWordElement.textContent = game.carriedWord;
                carriedWordElement.classList.add('visible');
                // Position above character
                carriedWordElement.style.left = (game.x + 32) + 'px';
                carriedWordElement.style.top = (game.y - 30) + 'px';
            } else {
                carriedWordElement.classList.remove('visible');
            }
        }

        // Normalize text block: move period to end, capitalize first letter, lowercase rest
        function normalizeTextBlock(location) {
            const words = textBlocks[location];
            if (words.length === 0) return;

            // Remove periods from all words
            words.forEach(word => {
                if (word.text.endsWith('.')) {
                    word.text = word.text.slice(0, -1);
                }
            });

            // Process each word for capitalization
            words.forEach((word, index) => {
                if (index === 0) {
                    // First word: capitalize first letter, lowercase the rest
                    word.text = word.text.charAt(0).toUpperCase() + word.text.slice(1).toLowerCase();
                } else {
                    // Other words: lowercase everything
                    word.text = word.text.toLowerCase();
                }
            });

            // Add period to the last word
            const lastWord = words[words.length - 1];
            if (!lastWord.text.endsWith('.')) {
                lastWord.text += '.';
            }

            // Update all element text contents
            words.forEach(word => {
                word.element.textContent = word.text;
            });
        }

        // Pick up a word (spacebar on hovered word, no carried word)
        function pickUpWord() {
            if (currentHoveredWord && !game.carriedWord) {
                const location = currentHoveredWord.location;
                const index = currentHoveredWord.index;
                const wordText = currentHoveredWord.text;

                // Remove period from carried word if present
                game.carriedWord = wordText.endsWith('.') ? wordText.slice(0, -1) : wordText;

                // Remove the word from the text block
                currentHoveredWord.element.remove();
                textBlocks[location].splice(index, 1);

                // Update indices
                textBlocks[location].forEach((word, i) => {
                    word.index = i;
                    word.element.dataset.index = i;
                });

                currentHoveredWord = null;

                // Normalize the text block (period at end, capitalize first letter, lowercase rest)
                normalizeTextBlock(location);

                // Check triggers after text change
                checkTriggers();
            }
        }

        // Insert carried word after hovered word
        function insertWord() {
            if (game.carriedWord && currentHoveredWord) {
                const location = currentHoveredWord.location;
                const index = currentHoveredWord.index;

                // Create new word element
                const wordSpan = document.createElement('span');
                wordSpan.className = 'word';
                wordSpan.textContent = game.carriedWord;
                wordSpan.dataset.location = location;

                // Insert after the hovered word
                const nextElement = currentHoveredWord.element.nextSibling;
                if (nextElement) {
                    textContainers[location].insertBefore(wordSpan, nextElement);
                } else {
                    textContainers[location].appendChild(wordSpan);
                }

                // Update data structure
                const newWord = {
                    element: wordSpan,
                    text: game.carriedWord,
                    strikethrough: false,
                    location: location,
                    index: index + 1
                };
                textBlocks[location].splice(index + 1, 0, newWord);

                // Update indices
                textBlocks[location].forEach((word, i) => {
                    word.index = i;
                    word.element.dataset.index = i;
                });

                // Clear carried word
                game.carriedWord = null;

                // Normalize the text block (period at end, capitalize first letter, lowercase rest)
                normalizeTextBlock(location);

                // Check triggers after text change
                checkTriggers();
            }
        }

        // Animation frames for each direction
        const animations = {
            up: Array.from({length: 8}, (_, i) => `frames/08_Elliot_RPG_Walk Up_${i}.png`),
            down: Array.from({length: 8}, (_, i) => `frames/08_Elliot_RPG_Walk Down_${i}.png`),
            left: Array.from({length: 8}, (_, i) => `frames/08_Elliot_RPG_Walk Left_${i}.png`),
            right: Array.from({length: 8}, (_, i) => `frames/08_Elliot_RPG_Walk Right_${i}.png`)
        };

        // Animation frame counter
        let frameCounter = 0;
        const frameDelay = 6; // Change frame every 6 game frames

        // Initialize character position
        character.style.left = game.x + 'px';
        character.style.top = game.y + 'px';

        // Reload button click listener
        reloadButton.addEventListener('click', () => {
            if (currentScene) {
                loadScene(currentScene);
            }
        });

        // Keyboard event listeners
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key in game.keys) {
                game.keys[key] = true;
                e.preventDefault();
            }

            // Handle delete key
            if (e.key === 'Delete' && currentHoveredWord) {
                currentHoveredWord.strikethrough = !currentHoveredWord.strikethrough;
                if (currentHoveredWord.strikethrough) {
                    currentHoveredWord.element.classList.add('strikethrough');
                } else {
                    currentHoveredWord.element.classList.remove('strikethrough');
                }
                e.preventDefault();

                // Check triggers after text change
                checkTriggers();
            }

            // Handle spacebar
            if (e.key === ' ') {
                if (game.carriedWord) {
                    insertWord();
                } else {
                    pickUpWord();
                }
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in game.keys) {
                game.keys[key] = false;
                e.preventDefault();
            }
        });

        // Update game state
        function update() {
            let moved = false;
            let newDirection = game.direction;

            // Calculate new position based on keys pressed
            if (game.keys.w) {
                game.y -= game.speed;
                newDirection = 'up';
                moved = true;
            }
            if (game.keys.s) {
                game.y += game.speed;
                newDirection = 'down';
                moved = true;
            }
            if (game.keys.a) {
                game.x -= game.speed;
                newDirection = 'left';
                moved = true;
            }
            if (game.keys.d) {
                game.x += game.speed;
                newDirection = 'right';
                moved = true;
            }

            // Constrain to viewport
            const charWidth = 64;
            const charHeight = 64;
            game.x = Math.max(0, Math.min(window.innerWidth - charWidth, game.x));
            game.y = Math.max(0, Math.min(window.innerHeight - charHeight, game.y));

            // Update direction if changed
            if (moved && newDirection !== game.direction) {
                game.direction = newDirection;
                game.frame = 0;
                frameCounter = 0;
            }

            // Update animation frame if moving
            if (moved) {
                frameCounter++;
                if (frameCounter >= frameDelay) {
                    frameCounter = 0;
                    game.frame = (game.frame + 1) % 8;
                }
                game.isMoving = true;

                // Trigger on first movement
                if (!game.hasStartedMoving) {
                    game.hasStartedMoving = true;
                    // Load the home scene
                    loadScene('inside');
                }
            } else {
                game.isMoving = false;
                game.frame = 0; // Reset to idle frame when not moving
            }

            // Update character sprite
            character.src = animations[game.direction][game.frame];
            character.style.left = game.x + 'px';
            character.style.top = game.y + 'px';

            // Update word hover states
            updateWordHovers();

            // Update carried word position
            updateCarriedWord();
        }

        // Game loop
        function gameLoop() {
            update();
            requestAnimationFrame(gameLoop);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const charWidth = 64;
            const charHeight = 64;
            game.x = Math.max(0, Math.min(window.innerWidth - charWidth, game.x));
            game.y = Math.max(0, Math.min(window.innerHeight - charHeight, game.y));
        });

        // Start the game
        gameLoop();
    </script>
</body>
</html>
