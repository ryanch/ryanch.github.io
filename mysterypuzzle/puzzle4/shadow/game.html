<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Foreshadow Puzzle</title>
    <script src="https://unpkg.com/compromise"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: white;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #character {
            position: absolute;
            width: 64px;
            height: 64px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        #debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
        }

        .text-container {
            position: absolute;
            font-size: 48px;
            font-weight: bold;
            color: #333;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            pointer-events: none;
        }

        .text-container.visible {
            opacity: 1;
        }

        #text-top {
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            justify-content: center;
            max-width: 90%;
        }

        #text-bottom {
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            justify-content: center;
            max-width: 90%;
        }

        #text-left {
            left: 50px;
            top: 50%;
            transform: translateY(-50%);
            align-items: flex-start;
            width: 40%;
        }

        #text-right {
            right: 50px;
            top: 50%;
            transform: translateY(-50%);
            align-items: flex-end;
            width: 40%;
            justify-content: flex-end;
        }

        .word {
            position: relative;
            cursor: default;
            transition: color 0.2s ease;
        }

        .word.hover {
            color: #0066cc;
            text-shadow: 2px 2px 4px rgba(0, 102, 204, 0.3);
        }

        .word.strikethrough {
            text-decoration: line-through;
            text-decoration-thickness: 3px;
        }

        #carried-word {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            color: #0066cc;
            pointer-events: none;
            display: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        #carried-word.visible {
            display: block;
        }

        #reload-button, #controls-button {
            position: absolute;
            bottom: 20px;
            padding: 12px 24px;
            background-color: rgba(0, 102, 204, 0.8);
            color: white;
            border: 2px solid rgba(0, 102, 204, 1);
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease, background-color 0.2s ease;
        }

        #reload-button {
            right: 20px;
        }

        #controls-button {
            right: 130px;
        }

        #reload-button.visible, #controls-button.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #reload-button:hover, #controls-button:hover {
            background-color: rgba(0, 102, 204, 1);
        }

        #controls-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border: 3px solid rgba(0, 102, 204, 1);
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 1000;
            max-width: 400px;
        }

        #controls-modal.visible {
            display: block;
        }

        #controls-modal h2 {
            margin-top: 0;
            color: #0066cc;
            text-align: center;
            font-size: 28px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            font-size: 18px;
        }

        .control-key {
            background-color: #f0f0f0;
            border: 2px solid #ccc;
            border-radius: 6px;
            padding: 8px 16px;
            font-weight: bold;
            font-family: monospace;
            min-width: 80px;
            text-align: center;
        }

        .control-description {
            flex: 1;
            margin-left: 20px;
            color: #333;
        }

        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 999;
        }

        #modal-overlay.visible {
            display: block;
        }
    </style>
     <script src="https://unpkg.com/compromise"></script>
</head>
<body>
    <div id="game-container">
        <div id="text-top" class="text-container"></div>
        <div id="text-left" class="text-container"></div>
        <div id="text-right" class="text-container"></div>
        <div id="text-bottom" class="text-container"></div>
        <div id="carried-word"></div>
        <img id="character" src="frames/08_Elliot_RPG_Walk Down_0.png" alt="Character">
        <div id="debug-info"></div>
        <button id="controls-button">Controls</button>
        <button id="reload-button">Reload</button>
    </div>

    <div id="modal-overlay"></div>
    <div id="controls-modal">
        <h2>Controls</h2>
        <div class="control-item">
            <div class="control-key">W</div>
            <div class="control-description">Move Up</div>
        </div>
        <div class="control-item">
            <div class="control-key">A</div>
            <div class="control-description">Move Left</div>
        </div>
        <div class="control-item">
            <div class="control-key">S</div>
            <div class="control-description">Move Down</div>
        </div>
        <div class="control-item">
            <div class="control-key">D</div>
            <div class="control-description">Move Right</div>
        </div>
        <div class="control-item">
            <div class="control-key">SPACE</div>
            <div class="control-description">Pick up / Insert word</div>
        </div>
        <div class="control-item">
            <div class="control-key">DELETE</div>
            <div class="control-description">Strike out word</div>
        </div>
        <div class="control-item">
            <div class="control-key">TAB</div>
            <div class="control-description">Select other word</div>
        </div>
    </div>

    <script src="scenes.js"></script>
    <script src="shared_matching.js"></script>
    <script>
        const character = document.getElementById('character');
        const gameContainer = document.getElementById('game-container');
        const debugInfo = document.getElementById('debug-info');
        const textContainers = {
            top: document.getElementById('text-top'),
            left: document.getElementById('text-left'),
            right: document.getElementById('text-right'),
            bottom: document.getElementById('text-bottom')
        };
        const carriedWordElement = document.getElementById('carried-word');
        const reloadButton = document.getElementById('reload-button');
        const controlsButton = document.getElementById('controls-button');
        const controlsModal = document.getElementById('controls-modal');
        const modalOverlay = document.getElementById('modal-overlay');

        // Check if compromise.js loaded successfully
        let nlpAvailable = false;
        if (typeof nlp !== 'undefined') {
            nlpAvailable = true;
            console.log('Compromise.js loaded successfully');
        } else {
            console.warn('Compromise.js not available - nlpMatch features disabled');
        }

        // Game state
        const game = {
            x: window.innerWidth / 2 - 32,
            y: window.innerHeight / 2 - 32,
            speed: 3.5,
            direction: 'down',
            frame: 0,
            isMoving: false,
            hasStartedMoving: false,
            carriedWord: null,
            keys: {
                w: false,
                a: false,
                s: false,
                d: false
            }
        };

        // Text blocks management
        const textBlocks = {
            top: [],
            left: [],
            right: [],
            bottom: []
        };
        let currentHoveredWord = null;
        let lastHoveredWords = new Set(); // Track which words we were hovering last frame
        let currentlyCollidingWordsList = []; // List of all words currently being collided with
        let selectionIndex = 0; // Current index in the collision list

        // Scene management
        let currentScene = null;
        let triggeredBlocks = new Set();

        // Normalize text for matching (lowercase, remove punctuation, remove strikethrough, collapse spaces)
        function normalizeText(location) {
            const words = textBlocks[location];
            const textParts = words
                .filter(word => !word.strikethrough)
                .map(word => word.text);
            const text = textParts.join(' ');
            // Use shared normalization function
            return normalizeTextFromString(text);
        }

        // matchesPattern is now defined in shared_matching.js

        // NLP helper functions and nlpMatchesFunction are now defined in shared_matching.js
        const nlpHelpers = getNLPHelpers();

        // Get scene by name
        function getScene(sceneName) {
            return scenes.find(s => s.scene === sceneName);
        }

        // Parse action key (e.g., "setTopText1" -> {action: "setText", location: "top", order: 1})
        function parseActionKey(key) {
            const setTextMatch = key.match(/^set(Top|Left|Right|Bottom)Text(\d+)$/);
            if (setTextMatch) {
                return {
                    action: 'setText',
                    location: setTextMatch[1].toLowerCase(),
                    order: parseInt(setTextMatch[2])
                };
            }
            if (key === 'gotoScene') {
                return { action: 'gotoScene' };
            }
            return null;
        }

        // Execute actions with proper ordering and timing
        function executeActions(actions) {
            // Group actions by order
            const actionsByOrder = {};
            const gotoSceneAction = { action: null, value: null };

            Object.entries(actions).forEach(([key, value]) => {
                const parsed = parseActionKey(key);
                if (!parsed) return;

                if (parsed.action === 'gotoScene') {
                    gotoSceneAction.action = parsed.action;
                    gotoSceneAction.value = value;
                } else if (parsed.action === 'setText') {
                    const order = parsed.order || 1;
                    if (!actionsByOrder[order]) {
                        actionsByOrder[order] = [];
                    }
                    actionsByOrder[order].push({ ...parsed, value });
                }
            });

            // Execute setText actions in order with delays
            const orders = Object.keys(actionsByOrder).sort((a, b) => a - b);
            orders.forEach((order, index) => {
                const delay = index * 2000; // 2 seconds between each order
                setTimeout(() => {
                    actionsByOrder[order].forEach(action => {
                        setText(action.location, action.value, true);
                    });
                }, delay);
            });

            // Execute gotoScene if present (after all setText actions)
            if (gotoSceneAction.action === 'gotoScene') {
                const totalDelay = orders.length * 2000 + 500;
                setTimeout(() => {
                    loadScene(gotoSceneAction.value);
                }, totalDelay);
            }
        }

        // Check if_ triggers
        function checkTriggers() {
            if (!currentScene) return;

            const scene = getScene(currentScene);
            if (!scene) return;

            // Check all if_ blocks
            Object.entries(scene).forEach(([key, block]) => {
                if (!key.startsWith('if_')) return;
                if (triggeredBlocks.has(key)) return; // Already triggered

                let shouldTrigger = false;

                // Check legacy match field
                const matchValue = block.match;
                if (matchValue) {
                    // Convert single pattern to array for uniform processing
                    const patterns = Array.isArray(matchValue) ? matchValue : [matchValue];

                    // Check each location separately
                    ['top', 'left', 'right', 'bottom'].forEach(location => {
                        const normalized = normalizeText(location);

                        // Check if any pattern matches
                        const hasMatch = patterns.some(pattern => matchesPattern(normalized, pattern));

                        if (hasMatch) {
                            shouldTrigger = true;
                        }
                    });
                }

                // Check new nlpMatch field
                const nlpMatchValue = block.nlpMatch;
                if (nlpMatchValue && !shouldTrigger) {
                    const nlpFunctions = Array.isArray(nlpMatchValue) ? nlpMatchValue : [nlpMatchValue];

                    ['top', 'left', 'right', 'bottom'].forEach(location => {
                        const normalized = normalizeText(location);
                        const hasMatch = nlpFunctions.some(fn => nlpMatchesFunction(normalized, fn));
                        if (hasMatch) shouldTrigger = true;
                    });
                }

                if (shouldTrigger) {
                    triggeredBlocks.add(key);
                    executeActions(block);
                }
            });
        }

        // Load a scene
        function loadScene(sceneName) {
            const scene = getScene(sceneName);
            if (!scene) {
                console.error('Scene not found:', sceneName);
                return;
            }

            const isFirstLoad = currentScene === null;
            currentScene = sceneName;
            triggeredBlocks.clear();

            // Update URL hash
            window.location.hash = sceneName;

            // Clear carried word
            game.carriedWord = null;

            // Show reload and controls buttons when reaching intro scene
            if (sceneName === 'intro') {
                reloadButton.classList.add('visible');
                controlsButton.classList.add('visible');
            }

            // Fade out all existing text (skip if first load)
            if (!isFirstLoad) {
                ['top', 'left', 'right', 'bottom'].forEach(location => {
                    textContainers[location].classList.remove('visible');
                });
            }

            // Wait for fade-out transition to complete (1.5s) before clearing and loading new scene
            // Skip delay on first load since there's nothing to fade out
            const fadeOutDelay = isFirstLoad ? 0 : 1500;
            setTimeout(() => {
                // Clear all text content
                ['top', 'left', 'right', 'bottom'].forEach(location => {
                    setText(location, '', false);
                });

                // Execute start actions after a small delay to ensure clean slate
                setTimeout(() => {
                    if (scene.start) {
                        executeActions(scene.start);
                    }
                }, 50);
            }, fadeOutDelay);
        }

        // Validate scenes.js file format
        function validateScenes() {
            const errors = [];
            const warnings = [];

            if (!Array.isArray(scenes)) {
                errors.push('scenes must be an array');
                return { valid: false, errors, warnings };
            }

            const sceneNames = new Set();

            scenes.forEach((scene, index) => {
                const sceneId = `Scene ${index}`;

                // Check for required 'scene' field
                if (!scene.scene) {
                    errors.push(`${sceneId}: Missing required 'scene' field`);
                } else {
                    if (typeof scene.scene !== 'string') {
                        errors.push(`${sceneId}: 'scene' must be a string`);
                    }
                    if (sceneNames.has(scene.scene)) {
                        errors.push(`${sceneId}: Duplicate scene name '${scene.scene}'`);
                    }
                    sceneNames.add(scene.scene);
                }

                // Check start block if present
                if (scene.start) {
                    if (typeof scene.start !== 'object') {
                        errors.push(`${sceneId} (${scene.scene}): 'start' must be an object`);
                    } else {
                        validateActions(scene.start, `${sceneId} (${scene.scene}) start`, errors, warnings);
                    }
                }

                // Check if_ blocks
                Object.entries(scene).forEach(([key, block]) => {
                    if (!key.startsWith('if_')) return;
                    if (key === 'if_') {
                        errors.push(`${sceneId} (${scene.scene}): if_ block must have a name after 'if_'`);
                        return;
                    }

                    if (typeof block !== 'object') {
                        errors.push(`${sceneId} (${scene.scene}) ${key}: if_ block must be an object`);
                        return;
                    }

                    // Validate match or nlpMatch exists
                    if (!block.match && !block.nlpMatch) {
                        errors.push(`${sceneId} (${scene.scene}) ${key}: Missing required 'match' or 'nlpMatch' field`);
                    }

                    // Validate match field if present
                    if (block.match) {
                        if (typeof block.match !== 'string' && !Array.isArray(block.match)) {
                            errors.push(`${sceneId} (${scene.scene}) ${key}: 'match' must be a string or an array`);
                        } else if (Array.isArray(block.match)) {
                            // Validate array elements are strings
                            if (block.match.length === 0) {
                                errors.push(`${sceneId} (${scene.scene}) ${key}: 'match' array cannot be empty`);
                            }
                            block.match.forEach((pattern, index) => {
                                if (typeof pattern !== 'string') {
                                    errors.push(`${sceneId} (${scene.scene}) ${key}: 'match' array element ${index} must be a string`);
                                }
                            });
                        }
                    }

                    // Validate nlpMatch field if present
                    if (block.nlpMatch) {
                        if (typeof block.nlpMatch !== 'function' && !Array.isArray(block.nlpMatch)) {
                            errors.push(`${sceneId} (${scene.scene}) ${key}: 'nlpMatch' must be a function or array`);
                        } else if (Array.isArray(block.nlpMatch)) {
                            if (block.nlpMatch.length === 0) {
                                errors.push(`${sceneId} (${scene.scene}) ${key}: 'nlpMatch' array cannot be empty`);
                            }
                            block.nlpMatch.forEach((fn, index) => {
                                if (typeof fn !== 'function') {
                                    errors.push(`${sceneId} (${scene.scene}) ${key}: 'nlpMatch' array element ${index} must be a function`);
                                }
                            });
                        }

                        if (!nlpAvailable) {
                            warnings.push(`${sceneId} (${scene.scene}) ${key}: nlpMatch field used but compromise.js not loaded`);
                        }
                    }

                    validateActions(block, `${sceneId} (${scene.scene}) ${key}`, errors, warnings);
                });
            });

            return {
                valid: errors.length === 0,
                errors,
                warnings
            };
        }

        // Validate action block
        function validateActions(actions, location, errors, warnings) {
            const validLocations = ['Top', 'Left', 'Right', 'Bottom'];
            const referencedScenes = new Set();

            Object.entries(actions).forEach(([key, value]) => {
                if (key === 'match' || key === 'nlpMatch') return; // Skip match and nlpMatch fields

                const setTextMatch = key.match(/^set(Top|Left|Right|Bottom)Text(\d+)$/);
                if (setTextMatch) {
                    const loc = setTextMatch[1];
                    const order = parseInt(setTextMatch[2]);

                    if (!validLocations.includes(loc)) {
                        errors.push(`${location}: Invalid location '${loc}' in '${key}'`);
                    }
                    if (order < 1 || order > 4) {
                        warnings.push(`${location}: Order ${order} in '${key}' is outside typical range (1-4)`);
                    }
                    if (typeof value !== 'string') {
                        errors.push(`${location}: Value for '${key}' must be a string`);
                    }
                } else if (key === 'gotoScene') {
                    if (typeof value !== 'string') {
                        errors.push(`${location}: gotoScene value must be a string`);
                    } else {
                        referencedScenes.add(value);
                    }
                } else {
                    warnings.push(`${location}: Unknown action '${key}'`);
                }
            });

            // Check if referenced scenes exist
            referencedScenes.forEach(sceneName => {
                if (!scenes.find(s => s.scene === sceneName)) {
                    errors.push(`${location}: Referenced scene '${sceneName}' does not exist`);
                }
            });
        }

        // Test suite for match feature
        function runMatchTests() {
            console.log('=== Running Match Feature Tests ===');

            const tests = [
                // User's specific test case
                {
                    name: "User test: 'The hero opened chest.' matches '*hero opened chest.'",
                    text: "The hero opened chest.",
                    pattern: "*hero opened chest.",
                    expected: true
                },
                // Basic exact match
                {
                    name: "Exact match",
                    text: "hello world",
                    pattern: "hello world",
                    expected: true
                },
                // Exact match with different case
                {
                    name: "Case insensitive match",
                    text: "Hello World",
                    pattern: "hello world",
                    expected: true
                },
                // Wildcard at start
                {
                    name: "Wildcard at start",
                    text: "the big door",
                    pattern: "*door",
                    expected: true
                },
                // Wildcard at end
                {
                    name: "Wildcard at end",
                    text: "the big door",
                    pattern: "the*",
                    expected: true
                },
                // Wildcard in middle
                {
                    name: "Wildcard in middle",
                    text: "the big heavy door",
                    pattern: "the*door",
                    expected: true
                },
                // Multiple wildcards
                {
                    name: "Multiple wildcards",
                    text: "the big locked heavy wooden door",
                    pattern: "the*locked*door",
                    expected: true
                },
                // Punctuation removed in normalization
                {
                    name: "Punctuation removed",
                    text: "hello, world!",
                    pattern: "hello world",
                    expected: true
                },
                // Should not match - different text
                {
                    name: "No match - different text",
                    text: "hello world",
                    pattern: "goodbye world",
                    expected: false
                },
                // Should not match - pattern requires more
                {
                    name: "No match - pattern too specific",
                    text: "door",
                    pattern: "the door",
                    expected: false
                },
                // Wildcard matches empty string
                {
                    name: "Wildcard matches nothing",
                    text: "the door",
                    pattern: "the*door",
                    expected: true
                },
                // Complex example with punctuation
                {
                    name: "Complex with punctuation",
                    text: "The hero walked around, searching for the door.",
                    pattern: "*hero*door",
                    expected: true
                },
                // Test with period
                {
                    name: "Pattern with period at end",
                    text: "opened chest.",
                    pattern: "opened chest",
                    expected: true
                },
                // Another user scenario variant
                {
                    name: "Variant: 'hero opened chest' matches '*opened chest'",
                    text: "hero opened chest",
                    pattern: "*opened chest",
                    expected: true
                },
                // Optional text tests
                {
                    name: "Optional: 'cat dog' matches 'cat [bear] dog'",
                    text: "cat dog",
                    pattern: "cat [bear] dog",
                    expected: true
                },
                {
                    name: "Optional: 'cat bear dog' matches 'cat [bear] dog'",
                    text: "cat bear dog",
                    pattern: "cat [bear] dog",
                    expected: true
                },
                {
                    name: "Optional: 'the door' matches 'the [big] door'",
                    text: "the door",
                    pattern: "the [big] door",
                    expected: true
                },
                {
                    name: "Optional: 'the big door' matches 'the [big] door'",
                    text: "the big door",
                    pattern: "the [big] door",
                    expected: true
                },
                {
                    name: "Optional: Multiple - 'cat dog' matches 'cat [big] [brown] dog'",
                    text: "cat dog",
                    pattern: "cat [big] [brown] dog",
                    expected: true
                },
                {
                    name: "Optional: Multiple - 'cat big dog' matches 'cat [big] [brown] dog'",
                    text: "cat big dog",
                    pattern: "cat [big] [brown] dog",
                    expected: true
                },
                {
                    name: "Optional: Multiple - 'cat brown dog' matches 'cat [big] [brown] dog'",
                    text: "cat brown dog",
                    pattern: "cat [big] [brown] dog",
                    expected: true
                },
                {
                    name: "Optional: Multiple - 'cat big brown dog' matches 'cat [big] [brown] dog'",
                    text: "cat big brown dog",
                    pattern: "cat [big] [brown] dog",
                    expected: true
                },
                {
                    name: "Optional with wildcard: 'the door' matches '*[big] door'",
                    text: "the door",
                    pattern: "*[big] door",
                    expected: true
                },
                {
                    name: "Optional with wildcard: 'the big door' matches '*[big] door'",
                    text: "the big door",
                    pattern: "*[big] door",
                    expected: true
                },
                {
                    name: "Optional with wildcard at front: 'the big door on the floor' matches '[the] big door*'",
                    text: "the big door on the floor",
                    pattern: "[the] big door*",
                    expected: true
                },
                {
                    name: "Optional: Should not match wrong text - 'cat mouse' vs 'cat [bear] dog'",
                    text: "cat mouse",
                    pattern: "cat [bear] dog",
                    expected: false
                },
                {
                    name: "Optional: With punctuation - 'Hello, world.' matches 'Hello[,] world[.]'",
                    text: "Hello, world.",
                    pattern: "Hello[,] world[.]",
                    expected: true
                }
            ];

            let passed = 0;
            let failed = 0;

            tests.forEach((test, index) => {
                // Normalize text (simulate what normalizeText does)
                const normalizedText = test.text
                    .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()'"]/g, '')
                    .toLowerCase()
                    .replace(/\s+/g, ' ')
                    .trim();

                const result = matchesPattern(normalizedText, test.pattern);
                const status = result === test.expected ? 'PASS' : 'FAIL';

                if (result === test.expected) {
                    passed++;
                    console.log(`✓ Test ${index + 1}: ${test.name}`);
                } else {
                    failed++;
                    console.error(`✗ Test ${index + 1}: ${test.name}`);
                    console.error(`  Text: "${test.text}" (normalized: "${normalizedText}")`);
                    console.error(`  Pattern: "${test.pattern}"`);
                    console.error(`  Expected: ${test.expected}, Got: ${result}`);
                }
            });

            console.log('\n=== Test Summary ===');
            console.log(`Total: ${tests.length}`);
            console.log(`Passed: ${passed}`);
            console.log(`Failed: ${failed}`);
            console.log(`Success Rate: ${((passed / tests.length) * 100).toFixed(1)}%`);
            console.log('====================\n');

            return { passed, failed, total: tests.length };
        }

        // Run match tests at startup
        runMatchTests();

        // Test suite for NLP match feature
        function runNLPMatchTests() {
            if (!nlpAvailable) {
                console.log('=== NLP Match Tests Skipped (compromise.js not loaded) ===\n');
                return { passed: 0, failed: 0, total: 0, skipped: true };
            }

            console.log('=== Running NLP Match Feature Tests ===');

            const tests = [
                {
                    name: "Basic: 'she goes down the stairs' matches hasVerb(go) && hasDirection(down)",
                    text: "she goes down the stairs",
                    fn: (doc, h) => h.hasVerb(doc, 'go') && h.hasDirection(doc, 'down'),
                    expected: true
                },
                {
                    name: "Verb tense: 'she went down stairs' matches hasVerb(go) && hasDirection(down)",
                    text: "she went down stairs",
                    fn: (doc, h) => h.hasVerb(doc, 'go') && h.hasDirection(doc, 'down'),
                    expected: true
                },
                {
                    name: "Negation: 'she does not go down' matches hasNegation && hasVerb(go)",
                    text: "she does not go down",
                    fn: (doc, h) => h.hasNegation(doc) && h.hasVerb(doc, 'go'),
                    expected: true
                },
                {
                    name: "Negation: 'she goes down' does NOT match hasNegation && hasVerb(go)",
                    text: "she goes down",
                    fn: (doc, h) => h.hasNegation(doc) && h.hasVerb(doc, 'go'),
                    expected: false
                },
                {
                    name: "No negation: 'she goes down' matches !hasNegation && hasVerb(go)",
                    text: "she goes down",
                    fn: (doc, h) => !h.hasNegation(doc) && h.hasVerb(doc, 'go'),
                    expected: true
                },
                {
                    name: "No negation: 'she does not go down' does NOT match !hasNegation && hasVerb(go)",
                    text: "she does not go down",
                    fn: (doc, h) => !h.hasNegation(doc) && h.hasVerb(doc, 'go'),
                    expected: false
                },
                {
                    name: "Contraction: 'she doesn't go down' matches hasNegation && hasVerb(go)",
                    text: "she doesn't go down",
                    fn: (doc, h) => h.hasNegation(doc) && h.hasVerb(doc, 'go'),
                    expected: true
                },
                {
                    name: "Direction: 'she moves up' matches hasDirection('up')",
                    text: "she moves up",
                    fn: (doc, h) => h.hasDirection(doc, 'up'),
                    expected: true
                },
                {
                    name: "Multiple directions: 'going left' matches hasDirection('up', 'down', 'left')",
                    text: "going left",
                    fn: (doc, h) => h.hasDirection(doc, 'up', 'down', 'left'),
                    expected: true
                },
                {
                    name: "Complex: 'she continues down the stairs' matches hasVerb && hasDirection",
                    text: "she continues down the stairs",
                    fn: (doc, h) => h.hasVerb(doc, 'continue') && h.hasDirection(doc, 'down'),
                    expected: true
                },
                {
                    name: "Using compromise API: 'she is scared' matches doc.has('#Pronoun') && doc.has('scared')",
                    text: "she is scared",
                    fn: (doc, h) => doc.has('#Pronoun') && doc.has('scared'),
                    expected: true
                },
                {
                    name: "Proper noun: 'Tessa is scared' matches checking for Tessa or pronoun",
                    text: "Tessa is scared",
                    fn: (doc, h) => (doc.has('#ProperNoun') || doc.has('#Pronoun')) && doc.has('scared'),
                    expected: true
                },
                {
                    name: "No match: 'she climbs up' vs hasVerb(go) && hasDirection(down)",
                    text: "she climbs up",
                    fn: (doc, h) => h.hasVerb(doc, 'go') && h.hasDirection(doc, 'down'),
                    expected: false
                }
            ];

            let passed = 0;
            let failed = 0;

            tests.forEach((test, index) => {
                // Normalize text (simulate what normalizeText does)
                const normalizedText = test.text
                    .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()'"]/g, '')
                    .toLowerCase()
                    .replace(/\s+/g, ' ')
                    .trim();

                const result = nlpMatchesFunction(normalizedText, test.fn);
                const status = result === test.expected ? 'PASS' : 'FAIL';

                if (result === test.expected) {
                    passed++;
                    console.log(`✓ NLP Test ${index + 1}: ${test.name}`);
                } else {
                    failed++;
                    console.error(`✗ NLP Test ${index + 1}: ${test.name}`);
                    console.error(`  Text: "${test.text}" (normalized: "${normalizedText}")`);
                    console.error(`  Expected: ${test.expected}, Got: ${result}`);
                }
            });

            console.log('\n=== NLP Test Summary ===');
            console.log(`Total: ${tests.length}`);
            console.log(`Passed: ${passed}`);
            console.log(`Failed: ${failed}`);
            console.log(`Success Rate: ${((passed / tests.length) * 100).toFixed(1)}%`);
            console.log('========================\n');

            return { passed, failed, total: tests.length };
        }

        // Run NLP tests at startup
        runNLPMatchTests();

        // Run validation on load
        const validation = validateScenes();
        if (!validation.valid) {
            console.error('Scene validation errors:');
            validation.errors.forEach(err => console.error('  - ' + err));
        }
        if (validation.warnings.length > 0) {
            console.warn('Scene validation warnings:');
            validation.warnings.forEach(warn => console.warn('  - ' + warn));
        }
        if (validation.valid) {
            console.log('Scenes file validated successfully');
        }

        // Set text for a specific location
        function setText(location, text, fadeIn = true) {
            const container = textContainers[location];
            if (!container) return;

            // Check if there's existing content that needs to fade out first
            const hasExistingContent = textBlocks[location].length > 0;

            if (hasExistingContent && fadeIn) {
                // Fade out existing content first
                container.classList.remove('visible');

                // Wait for fade-out transition to complete (1.5s) before updating content
                setTimeout(() => {
                    updateTextContent(container, location, text, fadeIn);
                }, 1500);
            } else {
                // No existing content or no fade requested, update immediately
                updateTextContent(container, location, text, fadeIn);
            }
        }

        // Helper function to update text content (separated for fade-out logic)
        function updateTextContent(container, location, text, fadeIn) {
            // Clear existing text
            container.innerHTML = '';
            textBlocks[location] = [];

            if (!text) return;

            // Ensure container is hidden before adding new content
            container.classList.remove('visible');

            // Create word elements
            const wordArray = text.split(' ');
            wordArray.forEach((wordText, index) => {
                const wordSpan = document.createElement('span');
                wordSpan.className = 'word';
                wordSpan.textContent = wordText;
                wordSpan.dataset.location = location;
                wordSpan.dataset.index = index;
                container.appendChild(wordSpan);

                textBlocks[location].push({
                    element: wordSpan,
                    text: wordText,
                    strikethrough: false,
                    location: location,
                    index: index
                });
            });

            // Fade in if requested (after a brief delay to ensure initial state is rendered)
            if (fadeIn) {
                // Force a reflow to ensure the opacity:0 state is rendered before transitioning
                container.offsetHeight;
                requestAnimationFrame(() => {
                    container.classList.add('visible');
                });
            }
        }

        // Get all words from all text blocks
        function getAllWords() {
            const allWords = [];
            ['top', 'left', 'right', 'bottom'].forEach(location => {
                allWords.push(...textBlocks[location]);
            });
            return allWords;
        }

        // Check collision between character and word
        function checkWordCollision(wordElement) {
            const charRect = character.getBoundingClientRect();
            const wordRect = wordElement.getBoundingClientRect();

            return !(charRect.right < wordRect.left ||
                     charRect.left > wordRect.right ||
                     charRect.bottom < wordRect.top ||
                     charRect.top > wordRect.bottom);
        }

        // Update word hover states
        function updateWordHovers() {
            const allWords = getAllWords();
            const currentlyCollidingWords = new Set();
            const collidingWordsList = [];

            // Find all words we're currently colliding with
            allWords.forEach(word => {
                if (checkWordCollision(word.element)) {
                    const wordId = `${word.location}_${word.index}`;
                    currentlyCollidingWords.add(wordId);
                    collidingWordsList.push(word);
                }
            });

            // Check if the set of colliding words has changed
            const collisionSetChanged =
                currentlyCollidingWords.size !== lastHoveredWords.size ||
                !Array.from(currentlyCollidingWords).every(id => lastHoveredWords.has(id));

            // Update the colliding words list and reset selection index if collision set changed
            if (collisionSetChanged) {
                currentlyCollidingWordsList = collidingWordsList;
                selectionIndex = 0;

                // Check if we've touched new words (not in lastHoveredWords)
                let newlyTouchedWord = null;
                for (const wordId of currentlyCollidingWords) {
                    if (!lastHoveredWords.has(wordId)) {
                        // This is a newly touched word
                        const [location, index] = wordId.split('_');
                        newlyTouchedWord = textBlocks[location][parseInt(index)];
                        break; // Use the first newly touched word we find
                    }
                }

                // Update the current hovered word
                if (newlyTouchedWord) {
                    // We touched a new word, select it
                    currentHoveredWord = newlyTouchedWord;
                    // Update selectionIndex to match
                    selectionIndex = collidingWordsList.indexOf(newlyTouchedWord);
                    if (selectionIndex === -1) selectionIndex = 0;
                } else if (currentHoveredWord) {
                    // Check if we're still hovering the current word
                    const currentWordId = `${currentHoveredWord.location}_${currentHoveredWord.index}`;
                    if (!currentlyCollidingWords.has(currentWordId)) {
                        // We're no longer touching the current word
                        // If we're still colliding with other words, select one of them
                        if (currentlyCollidingWords.size > 0) {
                            currentHoveredWord = collidingWordsList[0];
                            selectionIndex = 0;
                        } else {
                            currentHoveredWord = null;
                            selectionIndex = 0;
                        }
                    } else {
                        // Still hovering the same word, update its index in the new list
                        selectionIndex = collidingWordsList.indexOf(currentHoveredWord);
                        if (selectionIndex === -1) selectionIndex = 0;
                    }
                }
            } else {
                // Collision set hasn't changed, update list but keep selection
                currentlyCollidingWordsList = collidingWordsList;
                // Update selectionIndex to match currentHoveredWord in the updated list
                if (currentHoveredWord) {
                    const newIndex = collidingWordsList.indexOf(currentHoveredWord);
                    if (newIndex !== -1) {
                        selectionIndex = newIndex;
                    }
                }
            }

            // Update hover class - only the current hovered word should have it
            allWords.forEach(word => {
                if (word === currentHoveredWord) {
                    word.element.classList.add('hover');
                } else {
                    word.element.classList.remove('hover');
                }
            });

            // Update lastHoveredWords for next frame
            lastHoveredWords = currentlyCollidingWords;
        }

        // Update carried word position
        function updateCarriedWord() {
            if (game.carriedWord) {
                carriedWordElement.textContent = game.carriedWord;
                carriedWordElement.classList.add('visible');
                // Position above character
                carriedWordElement.style.left = (game.x + 32) + 'px';
                carriedWordElement.style.top = (game.y - 30) + 'px';
            } else {
                carriedWordElement.classList.remove('visible');
            }
        }

        // Normalize text block: move period to end, capitalize first letter, lowercase rest
        function normalizeTextBlock(location) {
            const words = textBlocks[location];
            if (words.length === 0) return;

            // Remove periods from all words
            words.forEach(word => {
                if (word.text.endsWith('.')) {
                    word.text = word.text.slice(0, -1);
                }
            });

            // Process each word for capitalization
            words.forEach((word, index) => {
                if (index === 0) {
                    // First word: capitalize first letter, lowercase the rest
                    word.text = word.text.charAt(0).toUpperCase() + word.text.slice(1).toLowerCase();
                } else {
                    // Other words: lowercase everything
                    word.text = word.text.toLowerCase();
                }
            });

            // Add period to the last word
            const lastWord = words[words.length - 1];
            if (!lastWord.text.endsWith('.')) {
                lastWord.text += '.';
            }

            // Update all element text contents
            words.forEach(word => {
                word.element.textContent = word.text;
            });
        }

        // Pick up a word (spacebar on hovered word, no carried word)
        function pickUpWord() {
            if (currentHoveredWord && !game.carriedWord) {
                const location = currentHoveredWord.location;
                const index = currentHoveredWord.index;
                const wordText = currentHoveredWord.text;

                // Remove period from carried word if present
                game.carriedWord = wordText.endsWith('.') ? wordText.slice(0, -1) : wordText;

                // Remove the word from the text block
                currentHoveredWord.element.remove();
                textBlocks[location].splice(index, 1);

                // Update indices
                textBlocks[location].forEach((word, i) => {
                    word.index = i;
                    word.element.dataset.index = i;
                });

                currentHoveredWord = null;

                // Normalize the text block (period at end, capitalize first letter, lowercase rest)
                normalizeTextBlock(location);

                // Check triggers after text change
                checkTriggers();
            }
        }

        // Insert carried word after hovered word
        function insertWord() {
            if (game.carriedWord && currentHoveredWord) {
                const location = currentHoveredWord.location;
                const index = currentHoveredWord.index;

                // Create new word element
                const wordSpan = document.createElement('span');
                wordSpan.className = 'word';
                wordSpan.textContent = game.carriedWord;
                wordSpan.dataset.location = location;

                // Insert after the hovered word
                const nextElement = currentHoveredWord.element.nextSibling;
                if (nextElement) {
                    textContainers[location].insertBefore(wordSpan, nextElement);
                } else {
                    textContainers[location].appendChild(wordSpan);
                }

                // Update data structure
                const newWord = {
                    element: wordSpan,
                    text: game.carriedWord,
                    strikethrough: false,
                    location: location,
                    index: index + 1
                };
                textBlocks[location].splice(index + 1, 0, newWord);

                // Update indices
                textBlocks[location].forEach((word, i) => {
                    word.index = i;
                    word.element.dataset.index = i;
                });

                // Clear carried word
                game.carriedWord = null;

                // Normalize the text block (period at end, capitalize first letter, lowercase rest)
                normalizeTextBlock(location);

                // Check triggers after text change
                checkTriggers();
            }
        }

        // Animation frames for each direction
        const animations = {
            up: Array.from({length: 8}, (_, i) => `frames/08_Elliot_RPG_Walk Up_${i}.png`),
            down: Array.from({length: 8}, (_, i) => `frames/08_Elliot_RPG_Walk Down_${i}.png`),
            left: Array.from({length: 8}, (_, i) => `frames/08_Elliot_RPG_Walk Left_${i}.png`),
            right: Array.from({length: 8}, (_, i) => `frames/08_Elliot_RPG_Walk Right_${i}.png`)
        };

        // Animation frame counter
        let frameCounter = 0;
        const frameDelay = 6; // Change frame every 6 game frames

        // Initialize character position
        character.style.left = game.x + 'px';
        character.style.top = game.y + 'px';

        // Reload button click listener
        reloadButton.addEventListener('click', () => {
            if (currentScene) {
                loadScene(currentScene);
            }
        });

        // Controls button click listener
        controlsButton.addEventListener('click', () => {
            controlsModal.classList.add('visible');
            modalOverlay.classList.add('visible');
        });

        // Close modal when clicking overlay
        modalOverlay.addEventListener('click', () => {
            controlsModal.classList.remove('visible');
            modalOverlay.classList.remove('visible');
        });

        // Keyboard event listeners
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key in game.keys) {
                game.keys[key] = true;
                e.preventDefault();
            }

            // Handle TAB key - cycle through multiple items at current position
            if (e.key === 'Tab') {
                e.preventDefault();
                if (currentlyCollidingWordsList.length > 1) {
                    // Increment selection index and wrap around
                    selectionIndex = (selectionIndex + 1) % currentlyCollidingWordsList.length;
                    currentHoveredWord = currentlyCollidingWordsList[selectionIndex];
                }
            }

            // Handle delete or backspace key
            if ((e.key === 'Delete' || e.key === 'Backspace') && currentHoveredWord) {
                currentHoveredWord.strikethrough = !currentHoveredWord.strikethrough;
                if (currentHoveredWord.strikethrough) {
                    currentHoveredWord.element.classList.add('strikethrough');
                } else {
                    currentHoveredWord.element.classList.remove('strikethrough');
                }
                e.preventDefault();

                // Check triggers after text change
                checkTriggers();
            }

            // Handle spacebar
            if (e.key === ' ') {
                if (game.carriedWord) {
                    insertWord();
                } else {
                    pickUpWord();
                }
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in game.keys) {
                game.keys[key] = false;
                e.preventDefault();
            }
        });

        // Update game state
        function update() {
            let moved = false;
            let newDirection = game.direction;

            // Calculate new position based on keys pressed
            if (game.keys.w) {
                game.y -= game.speed;
                newDirection = 'up';
                moved = true;
            }
            if (game.keys.s) {
                game.y += game.speed;
                newDirection = 'down';
                moved = true;
            }
            if (game.keys.a) {
                game.x -= game.speed;
                newDirection = 'left';
                moved = true;
            }
            if (game.keys.d) {
                game.x += game.speed;
                newDirection = 'right';
                moved = true;
            }

            // Constrain to viewport
            const charWidth = 64;
            const charHeight = 64;
            game.x = Math.max(0, Math.min(window.innerWidth - charWidth, game.x));
            game.y = Math.max(0, Math.min(window.innerHeight - charHeight, game.y));

            // Update direction if changed
            if (moved && newDirection !== game.direction) {
                game.direction = newDirection;
                game.frame = 0;
                frameCounter = 0;
            }

            // Update animation frame if moving
            if (moved) {
                frameCounter++;
                if (frameCounter >= frameDelay) {
                    frameCounter = 0;
                    game.frame = (game.frame + 1) % 8;
                }
                game.isMoving = true;

                // Trigger on first movement
                if (!game.hasStartedMoving) {
                    game.hasStartedMoving = true;
                    // Load the home scene
                    loadScene('home');
                }
            } else {
                game.isMoving = false;
                game.frame = 0; // Reset to idle frame when not moving
            }

            // Update character sprite
            character.src = animations[game.direction][game.frame];
            character.style.left = game.x + 'px';
            character.style.top = game.y + 'px';

            // Update word hover states
            updateWordHovers();

            // Update carried word position
            updateCarriedWord();
        }

        // Game loop
        function gameLoop() {
            update();
            requestAnimationFrame(gameLoop);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const charWidth = 64;
            const charHeight = 64;
            game.x = Math.max(0, Math.min(window.innerWidth - charWidth, game.x));
            game.y = Math.max(0, Math.min(window.innerHeight - charHeight, game.y));
        });

        // Check for scene in URL hash on page load
        function loadSceneFromHash() {
            const hash = window.location.hash.slice(1); // Remove the '#' character
            if (hash) {
                const scene = getScene(hash);
                if (scene) {
                    game.hasStartedMoving = true; // Skip waiting for first movement
                    loadScene(hash);
                } else {
                    console.warn('Scene in URL hash not found:', hash);
                }
            }
        }

        // Load scene from hash on page load
        loadSceneFromHash();

        // Start the game
        gameLoop();
    </script>
</body>
</html>
