<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brick Quips Configuration</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cpath d='M50 10 H14 C9 10 5 14 5 19 V40 C5 45 9 49 14 49 H20 L24 58 L28 49 H50 C55 49 59 45 59 40 V19 C59 14 55 10 50 10 Z' fill='%23FFD93D' stroke='%23000' stroke-width='3'/%3E%3C/svg%3E">
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Patrick+Hand&display=swap" rel="stylesheet">
    <link href="server_styles.css" rel="stylesheet">
</head>
<body>
    <div class="comic-star" style="top: 10%; left: 5%;">*</div>
    <div class="comic-star" style="top: 80%; right: 10%;">*</div>
    <div class="comic-star" style="top: 40%; left: 85%;">+</div>

    <div class="container">
        <h1>BRICK QUIPS</h1>
        <div class="subtitle">Device Configuration</div>

        <div class="status-bubble" id="status">
            <span id="statusText">Ready to discover devices</span>
        </div>

        <div id="bluetoothWarning" class="warning-bubble" style="display: none;">
            <h3>Bluetooth Not Supported</h3>
            <p>Web Bluetooth is not available in this browser. Please use Chrome, Edge, or Opera on a desktop/Android device.</p>
        </div>

        <div id="usbWarning" class="warning-bubble" style="display: none;">
            <h3>USB Serial Not Supported</h3>
            <p>Web Serial is not available in this browser. Please use Chrome or Edge on a desktop device.</p>
        </div>

        <button class="discover-btn" id="usbDiscoverBtn" onclick="discoverDevice('usb')">
            USB DISCOVERY
        </button>
        <button class="discover-btn" id="btDiscoverBtn" onclick="discoverDevice('bluetooth')">
            BLUETOOTH DISCOVERY
        </button>

        <div class="device-list" id="deviceList">
            <h2>Discovered Devices</h2>
            <div id="devicesContainer">
                <div class="no-devices">No devices discovered yet. Click a discover button to scan.</div>
            </div>
        </div>
    </div>

    <!-- Device Modal (fullscreen when connected) -->
    <div class="modal-overlay hidden" id="deviceModal">
        <!-- Connection UI (shown during connecting) -->
        <div class="modal-content" id="connectingContent" style="width: 90%; max-width: 600px;">
            <button class="modal-close" onclick="closeModal()">X</button>
            <div class="modal-header" id="modalDeviceName">Device</div>
            <div class="modal-status" id="modalStatus">
                <span id="modalStatusText">Connecting...</span>
                <span class="spinner" id="modalSpinner"></span>
            </div>
            <div class="modal-actions">
                <button class="action-btn disconnect" id="disconnectBtn" onclick="disconnectDevice()">
                    DISCONNECT
                </button>
            </div>
        </div>
        <!-- Fullscreen iframe (shown when connected) -->
        <iframe id="configIframe" src="" style="width:100vw; height:100vh; border:none; display:none; position:fixed; top:0; left:0;"></iframe>
    </div>

    <script>
        // Bluetooth UUIDs
        const SERVICE_UUID = '12345678-1234-5678-1234-56789abc0001';
        const READ_CHAR_UUID = '12345678-1234-5678-1234-56789abc0002';
        const WRITE_CHAR_UUID = '12345678-1234-5678-1234-56789abc0003';

        // BluetoothManager class
        class BluetoothManager {
            constructor() {
                this.device = null;
                this.server = null;
                this.service = null;
                this.readCharacteristic = null;
                this.writeCharacteristic = null;
            }

            async discover() {
                try {
                    const device = await navigator.bluetooth.requestDevice({
                        filters: [{ namePrefix: 'BrickQuip' }],
                        optionalServices: [SERVICE_UUID]
                    });
                    return device;
                } catch (error) {
                    if (error.name === 'NotFoundError') {
                        throw new Error('No device selected');
                    }
                    throw error;
                }
            }

            async connect(device) {
                this.device = device;

                // Listen for disconnection
                device.addEventListener('gattserverdisconnected', () => {
                    this.onDisconnected();
                });

                this.server = await device.gatt.connect();
                this.service = await this.server.getPrimaryService(SERVICE_UUID);
                this.readCharacteristic = await this.service.getCharacteristic(READ_CHAR_UUID);
                this.writeCharacteristic = await this.service.getCharacteristic(WRITE_CHAR_UUID);

                return true;
            }

            async readConfig() {
                if (!this.readCharacteristic) {
                    throw new Error('Not connected');
                }

                const value = await this.readCharacteristic.readValue();
                const decoder = new TextDecoder('utf-8');
                const jsonStr = decoder.decode(value);
                return JSON.parse(jsonStr);
            }

            async writeConfig(config) {
                if (!this.writeCharacteristic) {
                    throw new Error('Not connected');
                }

                const encoder = new TextEncoder();
                const data = encoder.encode(JSON.stringify(config));
                await this.writeCharacteristic.writeValue(data);

                // Read back confirmation
                const response = await this.writeCharacteristic.readValue();
                const decoder = new TextDecoder('utf-8');
                return JSON.parse(decoder.decode(response));
            }

            disconnect() {
                if (this.device && this.device.gatt.connected) {
                    this.device.gatt.disconnect();
                }
                this.cleanup();
            }

            cleanup() {
                this.server = null;
                this.service = null;
                this.readCharacteristic = null;
                this.writeCharacteristic = null;
            }

            onDisconnected() {
                this.cleanup();
                updateModalForDisconnection();
            }

            isConnected() {
                return this.device && this.device.gatt && this.device.gatt.connected;
            }

            getDeviceName() {
                return this.device ? this.device.name : null;
            }
        }

        // Low-level USB connection handler with callback-based API
        class UnReliableUSBConnectionManager {
            constructor() {
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.readBuffer = '';
                this.readLoopActive = false;
                this.responseResolver = null;
                this.readableStreamClosed = null; 
                this.writableStreamClosed = null; 
            }

            async connect(port) {
                try {
                    this.port = port;
                    await this.port.open({ baudRate: 115200 });

                    const textDecoder = new TextDecoderStream();
                    const textEncoder = new TextEncoderStream();

                    // Store pipe promises for later cleanup
                    this.abortController = new AbortController();
                    this.readableStreamClosed = this.port.readable.pipeTo(
                        textDecoder.writable,
                        { signal: this.abortController.signal }
                    ).catch(e => console.error("Readable pipe error:", e));

                    this.writableStreamClosed = textEncoder.readable.pipeTo(
                        this.port.writable
                    ).catch(e => console.error("Writable pipe error:", e));

                    this.reader = textDecoder.readable.getReader();
                    this.writer = textEncoder.writable.getWriter();

                    await new Promise(resolve => setTimeout(resolve, 100));
                    this.readLoopActive = true;
                    this.startReadLoop();

                    return { success: true };
                } catch (error) {
                    // Cleanup on connect failure
                    await this.disconnect();
                    return { success: false, error: error.message };
                }
            }

            /*
            async connect(port) {
                try {
                    this.port = port;
                    console.log("UnReliable: Opening port...");
                    await this.port.open({ baudRate: 115200 });
                    console.log("UnReliable: Port opened");

                    const textDecoder = new TextDecoderStream();
                    const textEncoder = new TextEncoderStream();

                    // new way
                    this.abortController = new AbortController();
                    this.port.readable.pipeTo(
                    textDecoder.writable,
                    { signal: this.abortController.signal }
                    ).catch(e => console.error("UnReliable: readable pipe error:", e));

                    // vs this:
                    //this.port.readable.pipeTo(textDecoder.writable).catch(e => console.error("UnReliable: readable pipe error:", e));
                    
                    textEncoder.readable.pipeTo(this.port.writable).catch(e => console.error("UnReliable: writable pipe error:", e));

                    this.reader = textDecoder.readable.getReader();
                    this.writer = textEncoder.writable.getWriter();

                    await new Promise(resolve => setTimeout(resolve, 100));

                    
                    this.readLoopActive = true;
                    this.startReadLoop();

                    return { success: true };
                } catch (error) {
                    console.error("UnReliable: Connect error:", error);
                    return { success: false, error: error.message };
                }
            }
            */

            /*
            // not clean:
            disconnect() {
                console.log("UnReliable: Disconnecting...");
                this.readLoopActive = false;

                // Abort the readable pipe first
                if (this.abortController) {
                    this.abortController.abort();
                    this.abortController = null;
                }

                if (this.responseResolver) {
                    this.responseResolver(null, false);
                    this.responseResolver = null;
                }

                try {
                    this.reader?.cancel().catch(() => {});
                    this.reader?.releaseLock();
                } catch (e) {}

                try {
                    this.writer?.releaseLock();
                } catch (e) {}

                try { this.port?.close().catch(() => {}); } catch (e) {}

                this.port = null;
                this.reader = null;
                this.writer = null;
                this.readBuffer = '';
            }
            */

            /*
            async disconnect() {  // Make async
                console.log("UnReliable: Disconnecting...");
                this.readLoopActive = false;

                if (this.abortController) {
                    this.abortController.abort();
                    this.abortController = null;
                }
                if (this.responseResolver) {
                    this.responseResolver(null, false);
                    this.responseResolver = null;
                }

                // Sequential cleanup - CRITICAL for pipeTo() chains
                try {
                    // 1. Cancel reader FIRST (unblocks pipeTo)
                    if (this.reader) {
                        await this.reader.cancel({ flush: false });
                        this.reader.releaseLock();
                    }
                } catch (e) { console.error("Reader cancel:", e); }

                try {
                    // 2. Close writer (propagates through textEncoder -> port.writable)
                    if (this.writer) {
                        await this.writer.close();
                        this.writer.releaseLock();
                    }
                } catch (e) { console.error("Writer close:", e); }

                try {
                    // 3. Port close LAST
                    if (this.port) {
                        await this.port.close();
                    }
                } catch (e) { console.error("Port close:", e); }

                // Cleanup
                this.port = null; this.reader = null; this.writer = null; 
                this.readBuffer = '';
            }
            */

            async disconnect() {
                console.log("UnReliable: Disconnecting...");
                this.readLoopActive = false;

                if (this.responseResolver) {
                    this.responseResolver(null, false);
                    this.responseResolver = null;
                }

                if (this.abortController) {
                    this.abortController.abort();
                    this.abortController = null;
                }

                // 1. Cancel reader (unblocks readable pipe)
                try {
                    if (this.reader) {
                        await this.reader.cancel();
                        this.reader.releaseLock();
                    }
                } catch (e) {
                    console.error("Reader cancel:", e);
                }

                // 2. Close writer (propagates through textEncoder -> port.writable)
                try {
                    if (this.writer) {
                        await this.writer.close();
                        this.writer.releaseLock();
                    }
                } catch (e) {
                    console.error("Writer close:", e);
                }

                // 3. Wait for pipeTo chains to fully terminate
                try {
                    if (this.readableStreamClosed) {
                        await this.readableStreamClosed.catch(() => {});  // Ignore abort errors
                    }
                    if (this.writableStreamClosed) {
                        await this.writableStreamClosed;
                    }
                } catch (e) {
                    console.error("Stream close wait:", e);
                }

                // 4. NOW port.close() succeeds
                try {
                    if (this.port) {
                        await this.port.close();
                    }
                } catch (e) {
                    console.error("Port close:", e);
                }

                // Full cleanup
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.readBuffer = '';
                this.readableStreamClosed = null;
                this.writableStreamClosed = null;
            }


            async startReadLoop() {
                try {
                    while (this.readLoopActive && this.reader) {
                        const { value, done } = await this.reader.read();
                        if (done) break;
                        if (value) {
                            this.readBuffer += value;
                            let newlineIdx;
                            while ((newlineIdx = this.readBuffer.indexOf('\n')) !== -1) {
                                const response = this.readBuffer.substring(0, newlineIdx);
                                this.readBuffer = this.readBuffer.substring(newlineIdx + 1);
                                if (response.trim() && this.responseResolver) {
                                    // Pass raw text to resolver - let USBManager decide if it's valid
                                    console.log("UnReliable: Received response:", response.substring(0, 100));
                                    const resolver = this.responseResolver;
                                    this.responseResolver = null;
                                    resolver(response, true);
                                }
                            }
                        }
                    }
                } catch (error) {
                    if (this.readLoopActive) {
                        console.error('UnReliable: Read loop error:', error);
                        if (this.responseResolver) {
                            this.responseResolver(null, false);
                            this.responseResolver = null;
                        }
                    }
                }
            }

            sendRequest(jsonData, responseHandler) {
                if (!this.writer) {
                    console.error('UnReliable: Writer not available');
                    responseHandler(null, false);
                    return;
                }

                // Clear buffer before sending
                // this.readBuffer = '';

                const timeout = setTimeout(() => {
                    console.log("UnReliable: Response timeout");
                    if (this.responseResolver === wrappedHandler) {
                        this.responseResolver = null;
                        responseHandler(null, false);
                    }
                }, 5000);

                const wrappedHandler = (data, wasSuccess) => {
                    clearTimeout(timeout);
                    responseHandler(data, wasSuccess);
                };

                this.responseResolver = wrappedHandler;

                const json = JSON.stringify(jsonData) + '\n';
                console.log('UnReliable: Sending:', json.trim());
                this.writer.write(json).catch((err) => {
                    console.error('UnReliable: Write error:', err);
                    clearTimeout(timeout);
                    if (this.responseResolver === wrappedHandler) {
                        this.responseResolver = null;
                        responseHandler(null, false);
                    }
                });
            }

            isConnected() {
                return this.port !== null;
            }
        }

        // High-level USB manager with retry logic
        class USBManager {
            constructor() {
                this.connectionManager = new UnReliableUSBConnectionManager();
                this.deviceName = null;
                this.deviceId = null;
                this.currentPort = null;
                this.maxRetries = 10;

                window.addEventListener('beforeunload', () => {
                    this.connectionManager.disconnect();
                }, { once: true });


            }

            async discover() {
                try {
                    const port = await navigator.serial.requestPort({
                        filters: [
                            { usbVendorId: 0x303A }, // Espressif
                            { usbVendorId: 0x10C4 }, // Silicon Labs CP210x
                            { usbVendorId: 0x0403 }, // FTDI
                            { usbVendorId: 0x1A86 }  // CH340
                        ]
                    });
                    const deviceId = `usb-${Date.now()}`;
                    this.deviceId = deviceId;
                    return {
                        id: deviceId,
                        name: 'BrickQuip USB',
                        _port: port
                    };
                } catch (error) {
                    if (error.name === 'NotFoundError') {
                        throw new Error('No device selected');
                    }
                    throw error;
                }
            }

            async connect(device) {
                console.log("USBManager: Connecting to device:", device.name);
                this.currentPort = device._port;
                this.deviceName = device.name;
                this.deviceId = device.id;

                const result = await this.connectionManager.connect(this.currentPort);
                if (!result.success) {
                    throw new Error(result.error || 'Connection failed');
                }

                navigator.serial.addEventListener('disconnect', (e) => {
                    if (e.target === this.currentPort) {
                        this.onDisconnected();
                    }
                });

                return true;
            }

            async reconnect() {
                console.log("USBManager: Reconnecting...");
                this.connectionManager.disconnect();
                await new Promise(resolve => setTimeout(resolve, 500));
                const result = await this.connectionManager.connect(this.currentPort);
                return result.success;
            }

            async sendWithRetry(jsonData) {
                for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
                    console.log(`USBManager: Attempt ${attempt}/${this.maxRetries}`);

                    if (!this.connectionManager.isConnected()) {
                        console.log("USBManager: Not connected, reconnecting...");
                        const reconnected = await this.reconnect();
                        if (!reconnected) {
                            console.log("USBManager: Reconnect failed, will retry...");
                            await new Promise(resolve => setTimeout(resolve, 500));
                            continue;
                        }
                    }

                    const result = await new Promise((resolve) => {
                        this.connectionManager.sendRequest(jsonData, (response, wasSuccess) => {
                            resolve({ response, wasSuccess });
                        });
                    });

                    if (result.wasSuccess && result.response) {
                        try {
                            const data = JSON.parse(result.response);
                            console.log("USBManager: Valid JSON response:", data);
                            return data;
                        } catch (e) {
                            console.log("USBManager: Non-JSON response (will retry):", result.response.substring(0, 100));
                            // Continue to next attempt - non-JSON response (likely boot messages)
                            continue;
                        }
                    }

                    console.log("USBManager: Attempt failed, will disconnect and retry...");
                    this.connectionManager.disconnect();
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }

                throw new Error(`Failed after ${this.maxRetries} attempts`);
            }

            async ping() {
                console.log("USBManager: Sending ping...");
                const response = await this.sendWithRetry({ cmd: 'ping' });
                if (response?.status === 'ok' && response?.message === 'pong') {
                    console.log("USBManager: Pong received");
                    return true;
                }
                throw new Error('Invalid ping response');
            }

            async readConfig() {
                console.log("USBManager: Reading config...");
                return await this.sendWithRetry({ cmd: 'load' });
            }

            async writeConfig(config) {
                console.log("USBManager: Writing config...");
                return await this.sendWithRetry({ cmd: 'save', ...config });
            }

            async disconnect() {
                this.connectionManager.disconnect();
                this.currentPort = null;
            }

            async onDisconnected() {
                this.connectionManager.disconnect();
                this.currentPort = null;
                updateModalForDisconnection();
            }

            isConnected() {
                return this.currentPort !== null;
            }

            getDeviceName() {
                return this.deviceName;
            }
        }

        // Global state
        const btManager = new BluetoothManager();
        const usbManager = new USBManager();
        const deviceTypes = new Map(); // deviceId -> 'bluetooth' | 'usb'

        function getManagerForDevice(deviceId) {
            return deviceTypes.get(deviceId) === 'usb' ? usbManager : btManager;
        }
        const discoveredDevices = new Map();
        let currentDeviceId = null;

        // Check for Web Bluetooth and Web Serial support
        document.addEventListener('DOMContentLoaded', () => {
            let hasAnySupport = false;

            if (!navigator.bluetooth) {
                document.getElementById('bluetoothWarning').style.display = 'block';
                document.getElementById('btDiscoverBtn').disabled = true;
            } else {
                hasAnySupport = true;
            }

            if (!navigator.serial) {
                document.getElementById('usbWarning').style.display = 'block';
                document.getElementById('usbDiscoverBtn').disabled = true;
            } else {
                hasAnySupport = true;
            }

            if (!hasAnySupport) {
                updateStatus('No connectivity options available', true);
            }
        });

        function updateStatus(message, isError = false) {
            const statusBubble = document.getElementById('status');
            const statusText = document.getElementById('statusText');
            statusText.textContent = message;
            statusBubble.classList.toggle('error', isError);
        }

        async function discoverDevice(connectionType = 'bluetooth') {
            const isUsb = connectionType === 'usb';
            const btn = document.getElementById(isUsb ? 'usbDiscoverBtn' : 'btDiscoverBtn');
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'SCANNING...';
            updateStatus(`Scanning for BrickQuip devices via ${isUsb ? 'USB' : 'Bluetooth'}...`);

            const manager = isUsb ? usbManager : btManager;

            try {
                const device = await manager.discover();

                // Store device reference and type
                discoveredDevices.set(device.id, device);
                deviceTypes.set(device.id, connectionType);

                // Update UI
                updateDeviceList();
                updateStatus('Device found: ' + device.name);

                // Open modal for this device
                openDeviceModal(device.id);

            } catch (error) {
                if (error.message !== 'No device selected') {
                    updateStatus('Error: ' + error.message, true);
                    console.error('Discovery error:', error);
                } else {
                    updateStatus('Discovery cancelled');
                }
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        function updateDeviceList() {
            const container = document.getElementById('devicesContainer');

            if (discoveredDevices.size === 0) {
                container.innerHTML = '<div class="no-devices">No devices discovered yet. Click a discovery button to scan.</div>';
                return;
            }

            container.innerHTML = '';
            discoveredDevices.forEach((device, id) => {
                const manager = getManagerForDevice(id);
                const isConnected = manager.isConnected() &&
                    (deviceTypes.get(id) === 'usb' ? manager.deviceId === id : manager.device && manager.device.id === id);
                const card = document.createElement('div');
                card.className = 'device-card' + (isConnected ? ' connected' : '');
                card.onclick = () => openDeviceModal(id);
                card.innerHTML = `
                    <span class="device-name">${device.name}</span>
                    <span class="device-status ${isConnected ? 'connected' : ''}">${isConnected ? 'Connected' : 'Click to connect'}</span>
                `;
                container.appendChild(card);
            });
        }

        async function openDeviceModal(deviceId) {
            currentDeviceId = deviceId;
            const device = discoveredDevices.get(deviceId);
            if (!device) return;

            const manager = getManagerForDevice(deviceId);
            const isUsb = deviceTypes.get(deviceId) === 'usb';

            // Show modal
            document.getElementById('deviceModal').classList.remove('hidden');
            document.getElementById('modalDeviceName').textContent = device.name;
            document.getElementById('configIframe').style.display = 'none';

            // Check if already connected to this device
            const alreadyConnected = manager.isConnected() &&
                (isUsb ? manager.deviceId === deviceId : manager.device && manager.device.id === deviceId);
            if (alreadyConnected) {
                updateModalConnected();
                return;
            }

            // If connected to different device, disconnect first
            if (manager.isConnected()) {
                manager.disconnect();
            }

            // Connect to this device
            updateModalConnecting();

            try {
                await manager.connect(device);
                updateDeviceList();

                // For USB, verify connection with ping before showing iframe
                if (isUsb) {
                    updateModalStatus('Verifying connection...');
                    await manager.ping();
                }

                updateModalConnected();
            } catch (error) {
                updateModalError('Connection failed: ' + error.message);
                console.error('Connection error:', error);
            }
        }

        function updateModalConnecting() {
            // Show connecting content, hide iframe
            document.getElementById("connectingContent").style.display = "block";
            document.getElementById("modalStatus").style.display = "block";
            document.getElementById("disconnectBtn").style.display = "block";

            document.getElementById('modalStatus').className = 'modal-status';
            document.getElementById('modalStatusText').textContent = 'Connecting...';
            document.getElementById('modalSpinner').style.display = 'inline-block';
            document.getElementById('configIframe').style.display = 'none';
        }

        function updateModalStatus(message) {
            document.getElementById('modalStatusText').textContent = message;
        }

        function updateModalConnected() {
            // Get device name for passing to iframe
            const device = discoveredDevices.get(currentDeviceId);
            const deviceName = device ? device.name : 'Device';

            // Hide connecting content, show fullscreen iframe
            document.getElementById("connectingContent").style.display = "none";

            // Load the configuration page in the iframe with PC_Mode and device_name
            const iframe = document.getElementById('configIframe');

            // when testing locally, use index.html from the root
            // when we host it on the web, we copy it to a sibling file, that is called device.html
            if (document.location.href.startsWith("file") ) {
                iframe.src = `../index.html?mode=PC_Mode&device_name=${encodeURIComponent(deviceName)}`;
            }
            else {
                iframe.src = `device.html?mode=PC_Mode&device_name=${encodeURIComponent(deviceName)}`;
            }

            iframe.style.display = 'block';
        }

        function updateModalError(message) {
            // Show connecting content with error state
            document.getElementById("connectingContent").style.display = "block";
            document.getElementById("modalStatus").style.display = "block";
            document.getElementById("disconnectBtn").style.display = "block";
            document.getElementById('modalStatus').className = 'modal-status error';
            document.getElementById('modalStatusText').textContent = message;
            document.getElementById('modalSpinner').style.display = 'none';
            document.getElementById('configIframe').style.display = 'none';
        }

        function updateModalForDisconnection() {
            if (document.getElementById('deviceModal').classList.contains('hidden')) {
                return;
            }
            updateModalError('Disconnected');
            updateDeviceList();
        }

        function closeModal() {
            document.getElementById('deviceModal').classList.add('hidden');
            document.getElementById('configIframe').src = '';
            document.getElementById('configIframe').style.display = 'none';
            document.getElementById('connectingContent').style.display = 'block';
            currentDeviceId = null;
        }

        function disconnectDevice() {
            if (currentDeviceId) {
                const manager = getManagerForDevice(currentDeviceId);
                manager.disconnect();
            }
            updateModalError('Disconnected');
            updateDeviceList();
            updateStatus('Disconnected from device');
        }

        // Handle postMessage requests from iframe for device communication
        window.addEventListener('message', async (event) => {
            // Handle close_dialog command from iframe
            if (event.data && event.data.xxx_local_command === 'close_dialog') {
                closeModal();
                return;
            }

            if (event.data && event.data.type === 'fetch') {
                const { requestId, url, options } = event.data;
                const iframe = document.getElementById('configIframe');
                const manager = currentDeviceId ? getManagerForDevice(currentDeviceId) : btManager;
                const connectionType = deviceTypes.get(currentDeviceId) === 'usb' ? 'USB' : 'Bluetooth';

                try {
                    let data;

                    if (url === '/api/quips/load') {
                        data = await manager.readConfig();
                        updateStatus(`Configuration loaded via ${connectionType}`);
                    } else if (url === '/api/quips/save') {
                        const payload = JSON.parse(options.body);
                        data = await manager.writeConfig(payload);
                        updateStatus(`Configuration saved via ${connectionType}`);
                    } else {
                        throw new Error('Unknown endpoint: ' + url);
                    }

                    iframe.contentWindow.postMessage({
                        type: 'fetchResponse',
                        requestId: requestId,
                        ok: true,
                        data: data
                    }, '*');
                } catch (error) {
                    console.error(`${connectionType} operation failed:`, error);
                    updateStatus(`${connectionType} error: ` + error.message, true);

                    iframe.contentWindow.postMessage({
                        type: 'fetchResponse',
                        requestId: requestId,
                        ok: false,
                        error: error.message
                    }, '*');
                }
            }
        });
    </script>
</body>
</html>
